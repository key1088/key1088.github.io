title: grub 命令行用法
categories: [Linux]
tags: []
date: 2010-05-19 11:49:00
---
<strong>1、用命令行来引导Linux操作系统的步骤<br /></strong><p>通过命令行来引导操作系统的流程，也没有什么难的；无非是把指令手工输入到grub&gt;提示符的后面；在这个过程中，tab键的命令补齐功能就 显得很重要了。如果您不知道有哪些命令，可以输入help；</p><p><strong><br />1）进入GRUB的命令行模式 grub&gt;<br /></strong><br />如果开机时，GRUB出现的是<strong>grub&gt;</strong>，说明你没有/etc/grub/menu.lst  ，您需要自己写一个才会GRUB的菜单，让我们来选择进入哪个系统。如果有GRUB的菜单，您可以按<strong>Ctrl+c</strong>组合 键进入GRUB的命令行模式，会出现<strong>grub&gt;</strong> 提示符；</p><code>grub&gt;</code><p><br /><strong><br />2）获取帮助GRUB的 help<br /></strong></p><p> </p><p>只要您在<strong>grub&gt;</strong>提示符的后面输入help 就能得到GRUB所有的命令提示；</p><p> </p><code>grub&gt; help<br />blocklist FILE boot<br />cat FILE chainloader [--force] FILE<br />clear color NORMAL [HIGHLIGHT]<br />configfile FILE device DRIVE DEVICE<br />displayapm displaymem<br />find FILENAME geometry DRIVE [CYLINDER HEAD SECTOR [<br />halt [--no-apm] help [--all] [PATTERN ...]<br />hide PARTITION initrd FILE [ARG ...]<br />kernel [--no-mem-option] [--type=TYPE] makeactive<br />map TO_DRIVE FROM_DRIVE md5crypt<br />module FILE [ARG ...] modulenounzip FILE [ARG ...]<br />pager [FLAG] partnew PART TYPE START LEN<br />parttype PART TYPE quit<br />reboot root [DEVICE [HDBIAS]]<br />rootnoverify [DEVICE [HDBIAS]] serial [--unit=UNIT] [--port=PORT] [--<br />setkey [TO_KEY FROM_KEY] setup [--prefix=DIR] [--stage2=STAGE2_<br />terminal [--dumb] [--no-echo] [--no-ed terminfo [--name=NAME  --cursor-address<br />testvbe MODE unhide PARTITION<br />uppermem KBYTES vbeprobe [MODE]</code><p>如果需要得到某个指令的帮助，就在 help 后面空一格，然后输入指令，比如；</p><p> </p><code>grub&gt;help kernel</code><p><br /><strong><br />3）cat的用法；<br /></strong></p><p> </p><p>cat指令是用来查看文件内容的，有时我们不知道Linux的/boot分区，以及/根分区所在的位置，要查看/etc/fstab的内容来得知， 这时，我们就要用到cat (hd[0-n],y)/etc/fstab 来获得这些内容；注意要学会用tab键命令补齐的功能；</p><code>grub&gt; cat ( 按tab  键会出来hd0或hd1之类的；<br />grub&gt; cat (hd0, 注：输入hd0,然后再按tab键；会出来分区之类的；<br />grub&gt; cat (hd0,6)<br />Possible partitions are:<br />Partition num: 0, Filesystem type unknown, partition type 0x7<br />Partition num: 4, Filesystem type is fat, partition type 0xb<br />Partition num: 5, Filesystem type is reiserfs, partition type 0x83<br />Partition num: 6, Filesystem type is ext2fs, partition type 0x83<br />Partition num: 7, Filesystem type unknown, partition type 0x83<br />Partition num: 8, Filesystem type is reiserfs, partition type 0x83<br />Partition num: 9, Filesystem type unknown, partition type 0x82<br />grub&gt; cat (hd0,6)/etc/fstab 注：比如我想查看一下 (hd0,6)/etc/fstab的内容就这样输入；<br />LABEL=/ / ext3 defaults 1 1<br />/dev/devpts /dev/pts devpts gid=5,mode=620 0 0<br />/dev/shm /dev/shm tmpfs defaults 0 0<br />/dev/proc /proc proc defaults 0 0<br />/dev/sys /sys sysfs defaults 0 0<br />LABEL=SWAP-hda1 swap swap defaults 0 0<br />/dev/hdc /media/cdrecorder auto pamconsole,exec,noauto,<br />managed 0 0</code><p>有的弟兄可能会说，我不知道Linux安装在了哪个分区。那根据文件系统来判断一个一个的尝试总可以吧我；只要能cat出/etc/fstab就能 为以后引导带来方便；</p><p>主要查看/etc/fstab中的内容，主要是Linux的/分区及/boot是否是独立的分区；如果没有/boot类似的行，证明/boot和 Linux的/处于同一个硬盘分区；比如上面的例子中LABEL=/ 这行是极为重要的；说明Linux系统就安在标签为LABEL=/的分区中；</p><p>如果您的Linux系统/boot和/没有位于同一个分区，可能cat (hd[a-n],y) 查到的是类似下面的；</p><p> </p><code>LABEL=/ / ext3 defaults 1 1<br />LABEL=/boot /boot ext3 defaults 1 2</code><p><strong><br />4） root (hd[0-n,y) 指令来指定/boot所在的分区；<br /></strong></p><p>其实这个root (hd[0,n],y)是可以省略的，如果省略了，我们要在kerenl 命令中指定；我们前面已经说过  (hd[0-n],y) 硬盘分区的表示方法的用途；主要是用来指定 /boot所在的分区；</p><p>比如我们确认/boot和 (hd0,6)，所以就可以这样来输入root (hd0,6)</p><code>grub&gt; root (hd0,6)</code><p>如果发现不对，可以重新来过；没有什么大不了的；</p><p><strong><br />5） kernel 指令，用来指定Linux的内核，及/所在的分区；<br /></strong></p><p>kernel 这个指令可能初学者有点怕，不知道内核在哪个分区，及内核文件名的全称是什么。不要忘记tab键的命令补齐的应用；<br /><strong><br />如果我们已经通过root (hd[0-n],y) 指定了/boot所在的分区，语法有两个：<br /></strong><br />如果/boot和Linux的/位于同一个分区，应该是下面的一种格式；<br /><strong><br />kernel /boot/vmlinuz在这里按tab键来补齐，就看到内核全称了 ro root=/dev/hd[a-z]X<br /></strong><br />如果/boot有自己独立的分区，应该是；<br /><strong><br />kernel /vmlinuz在这里按tab键来补齐，就看到内核全称了 ro root=/dev/hd[a-z]X<br /></strong></p><p>在这里 root=/dev/hd[a-z]X 是Linux  的/根所位于的分区，如果不知道是哪个分区，就用tab出来的来计算，一个一个的尝试；或用cat (hd[0-n],y)/etc/fstab  中得到Linux的/所在的分区或分区的标签；</p><p> </p><code>grub&gt; kernel  /boot/在这里按tab键；这样就列出/boot中的文件了；<br />Possible files are: grub initrd-2.6.11-1.1369_FC4.img  System.map-2.6.11-1.1369<br />_FC4 config-2.6.11-1.1369_FC4 vmlinuz-2.6.11-1.1369_FC4 grubBAK  memtest86+-1.55<br />.1 xen-syms xen.gz<br />grub&gt; kernel /boot/vmlinuz-2.6.11-1.1369_FC4 ro root=LABEL=/<br />[Linux-bzImage, setup=0x1e00, size=0x18e473]</code><p><strong>注解：</strong> root=LABEL=/  是Linux的/所在的分区的文件系统的标签；如果您知道Linux的/在哪个具体的分区，用root=/dev/hd[a-z]X来指定也行。比如下面 的一行也是可以的；</p><p> </p><code>grub&gt; kernel  /boot/vmlinuz-2.6.11-1.1369_FC4 ro root=/dev/hda7</code><p>也可以把/boot所在的分区的指定 root (hd[0-n],y)这行省掉，直接在kernel  中指定/boot所在的分区；所以就在下面的语法；</p><p>如果是/boot和Linux的根同处一个分区；</p><code>kernel  (hd[0-n],y)/boot/vmlinuz ro root=/dev/hd[a-z]X</code><p>比如：</p><code>grub&gt;kernel</code><p>如果是/boot和Linux所在的根不在一个分区；则是；</p><code>kernel (hd[0-n],y)/vmlinuz  ro root=/dev/hd[a-z]X</code><code>grub&gt; kernel  (hd0,6)/boot/vmlinuz-2.6.11-1.1369_FC4 ro root=/dev/hda7<br />[Linux-bzImage, setup=0x1e00, size=0x18e473]</code><p>或下面的输入，以cat 出/etc/fstab内容为准；</p><p> </p><code>grub&gt; kernel  (hd0,6)/boot/vmlinuz-2.6.11-1.1369_FC4 ro root=LABEL=/<br />[Linux-bzImage, setup=0x1e00, size=0x18e473]</code><p><strong><br />6）initrd 命令行来指定initrd文件；<br /></strong></p><p> </p><code>grub&gt; initrd  /boot/initrd在这里tab 来补齐；<br />grub&gt; initrd /boot/initrd-2.6.11-1.1369_FC4.img<br />[Linux-initrd @ 0x2e1000, 0x10e685 bytes]</code><p>如果/boot是独立的一个分区，应该是如下样子的语法；比如下面的；</p><p> </p><code>grub&gt; initrd  /initrd在这里tab 来补齐；<br />grub&gt; initrd /initrd-2.6.11-1.1369_FC4.img<br />[Linux-initrd @ 0x2e1000, 0x10e685 bytes]</code><p><br /><strong><br />7）boot 引导系统；<br /></strong></p><p> </p><p> </p><code>grub&gt;boot</code><code><strong>2、通过GRUB指令来引导 Windows ；<br /></strong></code><p> </p><p>其实我们会写menu.lst了，在menu.lst中的除了title外，都是一条条指
令；如果我们启动 Windows ，只是输入指令就行了；</p><p>比如 Windows的分区在 (hd0,0)，我们在开机后，按ctrl+c  ，进入GRUB的命令模式；就可以用下面的</p><p> </p><code>grub&gt; rootnoverify  (hd0,0)<br />grub&gt; chainloader +1<br />grub&gt; boot</code>